import torch
import numpy as np
import os
import matplotlib.pyplot as plt
import argparse

from PIL import Image as Image
from torch.nn import MSELoss
from torch.optim import Adam
from tqdm import tqdm

from utils import Timer
from network import UNet, ResNet, DnCNN
from restormer import Restormer
from drsformer import DRSformer
from data_online import train_dataloader
from generateSDR_multiple import generate_sdr

torch.manual_seed(3)
parser = argparse.ArgumentParser()
parser.add_argument("--rainy_data_path", type=str, default="./dataset/Rain100L/", help='Path to rainy data')
parser.add_argument("--sdr_data_path", type=str, default="./dataset/Rain100L/sdr/", help='Path to sdr data')
parser.add_argument("--result_path", type=str, default="./dataset/Rain100L/result/", help='Path to save result')
parser.add_argument("--backbone", type=str, default="Unet", help= "select backbone to be used in SDRL")
parser.add_argument("--epoch", type=int, default=100)
opt = parser.parse_args()

data_path = opt.rainy_data_path
save_path = opt.result_path
sdr_path = opt.sdr_data_path
epochs = opt.epoch

loss_function = MSELoss()
data_loader = train_dataloader(data_path, batch_size=1)
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

try:
    os.makedirs(save_path)
except:
    pass

epoch_timer = Timer('s') 
total_time = 0

for batch in data_loader:

    # train 
    rainy_images, clean_images, ldgp_images, name = batch
    epoch_timer.tic()    
    
    if opt.backbone == "Unet":
        model = UNet()
    elif opt.backbone == "ResNet":
        model = ResNet()
    elif opt.backbone == "DnCNN":
        model = DnCNN()
    elif opt.backbone == "Restormer":
        model = Restormer()
    elif opt.backbone == "DRSFormer":
        model = DRSFormer()

    model = model.to(device)
    optimizer = Adam(model.parameters(), lr=0.001)

    
    rainy_images = rainy_images.to(device)
    clean_images = clean_images.to(device)
    model.train()
    
    sdr_num = 50
    sdr_images = generate_sdr(rainy_images, ldgp_images, device, sdr_num)
    # denoised = np.clip(sdr_images[0][0].permute(1,2,0).detach().cpu().numpy(), 0, 1)
    # plt.imsave(os.path.join(save_path,"s"+name[0]), denoised)
    # exit()
    for epoch in tqdm(range(epochs)):
        net_output = model(rainy_images)
        loss = loss_function(net_output, sdr_images[epoch % sdr_num])
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()
    
    # inference

    model.eval()
    net_output = model(rainy_images)
    time = epoch_timer.toc()
    print("Time: ", time)
    total_time += time
    denoised = np.clip(net_output[0].permute(1,2,0).detach().cpu().numpy(), 0, 1)
    plt.imsave(os.path.join(save_path,name[0]), denoised)
    
    # except Exception as e:
    #     print("Exception occur: ", e)
    #     pass
    
print("Finish! Average Time:", total_time/len(data_loader))